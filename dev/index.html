<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sources · Microlensing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Microlensing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Sources</a><ul class="internal"><li><a class="toctext" href="#Caustics-1">Caustics</a></li><li><a class="toctext" href="#Parallel-caustics-1">Parallel caustics</a></li><li><a class="toctext" href="#Grids-and-cells-1">Grids and cells</a></li><li><a class="toctext" href="#Cell-trees-1">Cell trees</a></li><li><a class="toctext" href="#Magnification-1">Magnification</a></li><li><a class="toctext" href="#Parallel-magnification-1">Parallel magnification</a></li><li><a class="toctext" href="#Distributions-1">Distributions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Sources</a></li></ul><a class="edit-page" href="https://github.com/mikle97pir/Microlensing.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sources</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sources-1" href="#Sources-1">Sources</a></h1><h2><a class="nav-anchor" id="Caustics-1" href="#Caustics-1">Caustics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.simple_newton-Tuple{Any,Any,Any}" href="#Microlensing.simple_newton-Tuple{Any,Any,Any}"><code>Microlensing.simple_newton</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">simple_newton(f, ∂f, init)</code></pre><p>Finds the root of the complex function <code>f</code> near the initial value <code>init</code>. <code>∂f</code> is the derivative of <code>f</code>. The function is a straightforward implementation of Newton method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.find_corrections-NTuple{5,Any}" href="#Microlensing.find_corrections-NTuple{5,Any}"><code>Microlensing.find_corrections</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">find_corrections(masses, positions, δs, E, Λ)</code></pre><p>Finds the approximate positions of the <code>2*nstars</code> roots of the jacobian, when all the masses are multiplied by a small number <code>δs</code>. The output arrays <code>init1</code> and <code>init2</code> should be used for the function <a href="#Microlensing.find_start_roots-NTuple{6,Any}"><code>find_start_roots</code></a>.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L20-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.find_start_roots-NTuple{6,Any}" href="#Microlensing.find_start_roots-NTuple{6,Any}"><code>Microlensing.find_start_roots</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">find_start_roots(mass_homotopy, positions, init1, init2, δs, find_root)</code></pre><p>Finds the exact positions of the <code>2*nstars</code> roots of the jacobian, when all the masses are multiplied by a small number <code>δs</code>. The <code>init1</code> and <code>init2</code> initial approximations should be computed by the function <a href="#Microlensing.find_corrections-NTuple{5,Any}"><code>find_corrections</code></a>. </p><p><code>mass_homotopy</code> is a tuple of functions <code>(H, ∂tH, ∂sH, ∂ttH, ∂tsH)</code> containing the mass-changing homotopy <code>H(t, s)</code> and its derivatives. It should be generated by the function <a href="#Microlensing.create_mass_homotopy-NTuple{4,Any}"><code>create_mass_homotopy</code></a>.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L37-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.homotopy_step-NTuple{5,Any}" href="#Microlensing.homotopy_step-NTuple{5,Any}"><code>Microlensing.homotopy_step</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">homotopy_step(t0, s0, homotopy, Δs, find_root)</code></pre><p>Finds <code>t</code> such that <code>F(t, s) = 0</code>, where <code>s = s0 + Δs</code> and <code>F(t0, s0) = 0</code>. Returns <code>t</code> and <code>s</code>.</p><p><code>homotopy</code> is a tuple of functions <code>(F, ∂tF, ∂sF, ∂ttF, ∂tsF)</code> containing an arbitrary homotopy <code>F(t, s)</code> and its derivatives.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L60-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.auto_homotopy_step-NTuple{6,Any}" href="#Microlensing.auto_homotopy_step-NTuple{6,Any}"><code>Microlensing.auto_homotopy_step</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">auto_homotopy_step(t0, s0, homotopy, rate, lim_func, find_root)</code></pre><p>Does the same as <a href="#Microlensing.homotopy_step-NTuple{5,Any}"><code>homotopy_step</code></a>, but the step <code>Δs</code> is determined automatically. </p><p><code>lim_func</code> is a function with arguments <code>t0, s0, rate</code> that limits the step from the above. For the mass-changing homotopy we use <a href="#Microlensing.mass_lim_func-Tuple{Any,Any,Any}"><code>mass_lim_func</code></a>. For the angle-changing homotopy it is just a constant <code>2π / nsteps</code>.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L80-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.homotopize-NTuple{7,Any}" href="#Microlensing.homotopize-NTuple{7,Any}"><code>Microlensing.homotopize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">homotopize(t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)</code></pre><p>Finds <code>t</code> such that <code>F(t, s_finish) = 0</code>, if it&#39;s known that <code>F(t_start, s_start) = 0</code>. Returns <code>t</code>. Does this by repeating <a href="#Microlensing.auto_homotopy_step-NTuple{6,Any}"><code>auto_homotopy_step</code></a> many times to get from <code>s_start</code> to <code>s_finish</code>. </p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>, <a href="#Microlensing.homotopy_step-NTuple{5,Any}"><code>homotopy_step</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L99-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.homotopize_and_remember!-NTuple{9,Any}" href="#Microlensing.homotopize_and_remember!-NTuple{9,Any}"><code>Microlensing.homotopize_and_remember!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">homotopize_and_remember!(t_list, s_list, t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)</code></pre><p>Does the same as <a href="#Microlensing.homotopize-NTuple{7,Any}"><code>homotopize</code></a>, but saves all the intermediate values of <code>t</code> and <code>s</code> to empty lists <code>t_list</code> and <code>s_list</code> respectively. </p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>, <a href="#Microlensing.homotopy_step-NTuple{5,Any}"><code>homotopy_step</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L119-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.homotopize_and_remember-NTuple{7,Any}" href="#Microlensing.homotopize_and_remember-NTuple{7,Any}"><code>Microlensing.homotopize_and_remember</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">homotopize_and_remember(t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)</code></pre><p>Does the same as <a href="@ref"><code>homotopize_and_ramember!</code></a>, but creates <code>t_list</code> and s<em>list<code>itself and returns</code>t</em>list`.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>, <a href="#Microlensing.homotopy_step-NTuple{5,Any}"><code>homotopy_step</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L143-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.create_mass_homotopy-NTuple{4,Any}" href="#Microlensing.create_mass_homotopy-NTuple{4,Any}"><code>Microlensing.create_mass_homotopy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_mass_homotopy(masses, positions, E, Λ)</code></pre><p>Returns the tuple <code>mass_homotopy</code> containing the mass-changing homotopy <code>H</code> and its derivatives <code>∂tH, ∂sH, ∂ttH, ∂tsH</code>.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L164-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.create_angle_homotopy-NTuple{4,Any}" href="#Microlensing.create_angle_homotopy-NTuple{4,Any}"><code>Microlensing.create_angle_homotopy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_angle_homotopy(masses, positions, E, Λ)</code></pre><p>Returns the tuple <code>angle_homotopy</code> containing the angle-changing homotopy <code>G</code> and its derivatives <code>∂tG, ∂sG, ∂ttG, ∂tsG</code>.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L181-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.mass_lim_func-Tuple{Any,Any,Any}" href="#Microlensing.mass_lim_func-Tuple{Any,Any,Any}"><code>Microlensing.mass_lim_func</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mass_lim_func(t0, s0, rate)</code></pre><p>A limiting function for the step in the mass-changing homotopy.</p><p>See also: <a href="#Microlensing.evaluate_mass_homotopy-NTuple{7,Any}"><code>evaluate_mass_homotopy</code></a>, <a href="#Microlensing.homotopize_and_remember!-NTuple{9,Any}"><code>homotopize_and_remember!</code></a>, <a href="#Microlensing.homotopize-NTuple{7,Any}"><code>homotopize</code></a>, <a href="#Microlensing.auto_homotopy_step-NTuple{6,Any}"><code>auto_homotopy_step</code></a>, <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L197-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.evaluate_mass_homotopy-NTuple{7,Any}" href="#Microlensing.evaluate_mass_homotopy-NTuple{7,Any}"><code>Microlensing.evaluate_mass_homotopy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate_mass_homotopy(masses, positions, E, Λ, δs, rate, find_root)</code></pre><p>Evaluates the mass-changing homotopy from δs to 1 and returns the array with the roots of the jacobian for the angle equal to zero.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L207-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.evaluate_angle_homotopy-NTuple{8,Any}" href="#Microlensing.evaluate_angle_homotopy-NTuple{8,Any}"><code>Microlensing.evaluate_angle_homotopy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate_angle_homotopy(roots, masses, positions, E, Λ, rate, nsteps, find_root)</code></pre><p>Evaluates the angle-changing homotopy from 0 to 2π and returns a <code>Vector{Vector{Complex{Float64}}}</code>, which consists of vectors of points lying on the critical curves.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L226-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.check_for_duplicates-Tuple{Any}" href="#Microlensing.check_for_duplicates-Tuple{Any}"><code>Microlensing.check_for_duplicates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_for_duplicates(array)</code></pre><p>Returns <code>true</code> if the <code>array</code> contains approximate(<code>≈</code>) duplicates. Else returnes <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L247-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.duplicate_warning_crit_curves-Tuple{Any}" href="#Microlensing.duplicate_warning_crit_curves-Tuple{Any}"><code>Microlensing.duplicate_warning_crit_curves</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">duplicate_warning_crit_curves(crit_curves)</code></pre><p>Prints a warning if there are roots which glued to each other during the angle-changing homotopy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L264-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.duplicate_warning_roots-Tuple{Any}" href="#Microlensing.duplicate_warning_roots-Tuple{Any}"><code>Microlensing.duplicate_warning_roots</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">duplicate_warning_roots(roots)</code></pre><p>Prints a warning if there are roots which glued to each other during the mass-changing homotopy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L278-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_crit_curves" href="#Microlensing.calc_crit_curves"><code>Microlensing.calc_crit_curves</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">calc_crit_curves(masses, positions, E, Λ, δs=1e-6, rate=0.25, nsteps=200, find_root=simple_newton)</code></pre><p>Normally returns a <code>Vector{Vector{Complex{Float64}}}</code>, which consists of vectors of points lying on the critical curves.</p><p><strong>Arguments</strong></p><ul><li><code>masses</code>: the array containing the masses of the stars .</li><li><code>positions</code>: the array containing the complex coordinates of the stars.</li><li><code>E</code>, <code>Λ</code>: the lens parameters describing the external shear.</li><li><code>δs</code>: the starting parameter of the mass-changing homotopy; should be a small real number.</li><li><code>rate</code>: increasing this parameter effectively increases the adaptive step.</li><li><code>nsteps</code>: the minimal number of steps in the angle-changing homotopy; you should increase it if you want smoother curves.</li><li><code>find_root</code>: the root finder; its argumetns should be a complex function <code>f</code>, its derivative <code>∂f</code> and the initial approximation <code>init</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L291-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_caustics-NTuple{5,Any}" href="#Microlensing.calc_caustics-NTuple{5,Any}"><code>Microlensing.calc_caustics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calc_caustics(masses, positions, E, Λ, crit_curves)</code></pre><p>Computes the caustics by given critical curves <code>crit_curves</code>. </p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/caustics.jl#L314-L319">source</a></section><h2><a class="nav-anchor" id="Parallel-caustics-1" href="#Parallel-caustics-1">Parallel caustics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.par_evaluate_mass_homotopy-NTuple{7,Any}" href="#Microlensing.par_evaluate_mass_homotopy-NTuple{7,Any}"><code>Microlensing.par_evaluate_mass_homotopy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">par_evaluate_mass_homotopy(masses, positions, E, Λ, δs, rate, find_root)</code></pre><p>Does the same as <a href="#Microlensing.evaluate_mass_homotopy-NTuple{7,Any}"><code>evaluate_mass_homotopy</code></a>, but in a parallel way.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-caustics.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.par_evaluate_angle_homotopy" href="#Microlensing.par_evaluate_angle_homotopy"><code>Microlensing.par_evaluate_angle_homotopy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate_angle_homotopy(roots, masses, positions, E, Λ, rate, nsteps, find_root)</code></pre><p>Does the same as <a href="#Microlensing.evaluate_angle_homotopy-NTuple{8,Any}"><code>evaluate_angle_homotopy</code></a>, but in a parallel way.</p><p>See also: <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-caustics.jl#L18-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.par_calc_crit_curves" href="#Microlensing.par_calc_crit_curves"><code>Microlensing.par_calc_crit_curves</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">par_calc_crit_curves(masses, positions, E, Λ, δs=1e-6, rate=0.25, nsteps=200, find_root=simple_newton)</code></pre><p>Does the same as <a href="#Microlensing.calc_crit_curves"><code>calc_crit_curves</code></a>, but in a parallel way.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-caustics.jl#L35-L39">source</a></section><h2><a class="nav-anchor" id="Grids-and-cells-1" href="#Grids-and-cells-1">Grids and cells</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.get_index_leftup-Tuple{Microlensing.Grid,Any,Any}" href="#Microlensing.get_index_leftup-Tuple{Microlensing.Grid,Any,Any}"><code>Microlensing.get_index_leftup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_index_leftup(grid::Grid, i, j)</code></pre><p>Returns the complex coordinate of the upper left corner of the cell from the <code>i</code>-th row and <code>j</code>-th column.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/grids-and-cells.jl#L34-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.get_index_center-Tuple{Microlensing.Grid,Any,Any}" href="#Microlensing.get_index_center-Tuple{Microlensing.Grid,Any,Any}"><code>Microlensing.get_index_center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_index_center(grid::Grid, i, j)</code></pre><p>Returns the complex coordinate of the center of the cell from the <code>i</code>-th row and <code>j</code>-th column.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/grids-and-cells.jl#L44-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{Microlensing.Grid,Int64,Int64}" href="#Base.getindex-Tuple{Microlensing.Grid,Int64,Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Base.getindex(grid::Grid, i::Int, j::Int)</code></pre><p>Returns the cell from the <code>i</code>-th row and <code>j</code>-th column.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/grids-and-cells.jl#L54-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.matrix_rep" href="#Microlensing.matrix_rep"><code>Microlensing.matrix_rep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">matrix_rep(grid, n=grid.ngrid, kind=[:center or :leftup])</code></pre><p>Returns a matrix composed of the complex coordinates of the cells from <code>grid</code>. They can be either centers or upper left corners depending on <code>kind</code> argument.</p><p><code>n</code> argument tells where to stop: signature of resulting matrix is <code>(n, n)</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/grids-and-cells.jl#L64-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.dist-Tuple{Microlensing.AbstractCell,Microlensing.AbstractCell}" href="#Microlensing.dist-Tuple{Microlensing.AbstractCell,Microlensing.AbstractCell}"><code>Microlensing.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dist(c1::AbstractCell, c2::AbstractCell)</code></pre><p>Calculates the distance between two cells as closed subsets of metric space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/grids-and-cells.jl#L100-L104">source</a></section><h2><a class="nav-anchor" id="Cell-trees-1" href="#Cell-trees-1">Cell trees</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.CellNode-Tuple{}" href="#Microlensing.CellNode-Tuple{}"><code>Microlensing.CellNode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CellNode()</code></pre><p>Creates a self-referential sink. It is a placeholder for non-existing children.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.CellNode-Tuple{Microlensing.CellNode,Float64,Int64}" href="#Microlensing.CellNode-Tuple{Microlensing.CellNode,Float64,Int64}"><code>Microlensing.CellNode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CellNode(sink::CellNode, size::Float64, order::Int)</code></pre><p>Creates a node without children. Array <code>children</code> consists of four <code>sink</code>s. <code>order</code> is the higher multipole degree taken into account.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.CellTree-Tuple{Float64,Int64}" href="#Microlensing.CellTree-Tuple{Float64,Int64}"><code>Microlensing.CellTree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CellTree(size::Float64, order::Int)</code></pre><p>Creates a tree composed only of a root. All <code>root</code>&#39;s children are set to <code>sink</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L63-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.next_index-Tuple{Microlensing.CellNode,Star}" href="#Microlensing.next_index-Tuple{Microlensing.CellNode,Star}"><code>Microlensing.next_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">next_index(cell::CellNode, star::Star)</code></pre><p>Returns the index of <code>cell</code>&#39;s child containing given <code>star</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L114-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.child_center-Tuple{Microlensing.CellNode,Int64}" href="#Microlensing.child_center-Tuple{Microlensing.CellNode,Int64}"><code>Microlensing.child_center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">child_center(cell::CellNode, i::Int)</code></pre><p>Returns the center of the <code>i</code>-th child of the <code>cell</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L136-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.update_cell!-Tuple{Microlensing.CellNode,Star}" href="#Microlensing.update_cell!-Tuple{Microlensing.CellNode,Star}"><code>Microlensing.update_cell!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update_cell!(cell::CellNode, star::Star)</code></pre><p>Updates <code>mass</code> and <code>pos</code> of the <code>cell</code> when the <code>star</code> is added.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L147-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.add_cell!-Tuple{Microlensing.CellTree,Microlensing.CellNode,Star,Int64}" href="#Microlensing.add_cell!-Tuple{Microlensing.CellTree,Microlensing.CellNode,Star,Int64}"><code>Microlensing.add_cell!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_cell!(T::CellTree, cell::CellNode, star::Star, i::Int)</code></pre><p>Adds an <code>i</code>-th child containing <code>star</code> to the <code>cell</code>.</p><p>The square corresponding to the child <em>must</em> contain <code>star.pos</code>!</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L161-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.add_star!-Tuple{Microlensing.CellTree,Star}" href="#Microlensing.add_star!-Tuple{Microlensing.CellTree,Star}"><code>Microlensing.add_star!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_star!(T::CellTree, star::Star)</code></pre><p>Adds <code>star</code> to tree <code>T</code>.</p><p>It goes down the tree and modifies the cells until it meets a leaf. It then lengthens the branch until the stars are in different children.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L177-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.update_cell_multipoles!-Tuple{Microlensing.CellNode,Microlensing.CellNode,Array{Complex{Float64},1},Int64,Array{Int64,2}}" href="#Microlensing.update_cell_multipoles!-Tuple{Microlensing.CellNode,Microlensing.CellNode,Array{Complex{Float64},1},Int64,Array{Int64,2}}"><code>Microlensing.update_cell_multipoles!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update_cell_multipoles!(cell::CellNode, child::CellNode, 
                        degrees::Vector{Complex{Float64}}, 
                        order::Int, binomials::Matrix{Int})</code></pre><p>Updates <code>cell.multipoles</code> taking into account already known <code>child.multipoles</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cell::CellNode</code>: the cell being updated.</li><li><code>child::CellNode</code>: the child being taken into account.</li><li><code>degrees::Vector{Complex{Float64}}</code>: vector of length <code>order+1</code>. It&#39;s a temporary array for keeping degrees of <code>A-B</code> from <code>0</code> to <code>order</code>.</li><li><code>order::Int</code>: the degree of the highest multipole taken into account.</li><li><code>binomials::Matrix{Int}</code>: matrix of signature <code>(order, order)</code>. <code>binomials[i, j]</code> should be equal to <code>binomial(j-1, i-1)</code>. It is normally computed by the <a href="#Microlensing.calc_binomials-Tuple{Any}"><code>calc_binomials</code></a> function. </li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L230-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_binomials-Tuple{Any}" href="#Microlensing.calc_binomials-Tuple{Any}"><code>Microlensing.calc_binomials</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calc_binomials(order)</code></pre><p>Computes binomials. Returns matrix of signature <code>(order, order)</code>, <code>binomials[i, j]</code> should be equal to <code>binomial(j-1, i-1)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L271-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_multipoles!-Tuple{Microlensing.CellTree}" href="#Microlensing.calc_multipoles!-Tuple{Microlensing.CellTree}"><code>Microlensing.calc_multipoles!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calc_multipoles!(T::CellTree)</code></pre><p>Calculates multipoles for the whole tree. All the stars should be already added. The function propagates multipoles from the leaves to the root.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L287-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.build_tree" href="#Microlensing.build_tree"><code>Microlensing.build_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">build_tree(stars, size, order=6)</code></pre><p>Creates <code>CellTree</code> from a given array of stars. The root is centered at zero. </p><p><code>order</code> represents the highest multipole degree taken into account.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/cell-trees.jl#L332-L338">source</a></section><h2><a class="nav-anchor" id="Magnification-1" href="#Magnification-1">Magnification</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.NumMLProblem" href="#Microlensing.NumMLProblem"><code>Microlensing.NumMLProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Fields</strong></p><ul><li><code>T::CellTree</code>: normally is created with the <a href="#Microlensing.build_tree"><code>build_tree</code></a> function.</li><li><code>nstars::Int</code>: number of stars in simulation.</li><li><code>ngrid::Int</code>: <code>ngrid^2</code> is the number of the first level cells. For them the &quot;go down the tree and find the right nodes&quot; part of the computation is excecuted completely.</li><li><code>nshare::Int</code>: <code>nshare^2</code> is the number of the second level subcells of a first level cell. For them the computation is complete, but they all share the same tree structure of the first level cell containing them.</li><li><code>nint::Int</code>: <code>nint^2</code> is the number of the third level subcells of a second level cell. For them the algorithm attentively takes care of the stars located near the corresponding first level cell, but the impact of all other stars is interpolated.</li><li><code>resol::Int</code>: <code>resol×resol</code> is the resolution of the resulting magnification map.</li><li><code>E::Float64</code>: first parameter of the shear.</li><li><code>Λ::Float64</code>: second parameter of the shear.</li><li><code>δ::Float64</code>: the precision parameter. Higher <code>δ</code> - higher precision!</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_far_sums!-Tuple{Any,Cell,NumMLProblem,Array{Star,1},DataStructures.Stack{Microlensing.CellNode}}" href="#Microlensing.calc_far_sums!-Tuple{Any,Cell,NumMLProblem,Array{Star,1},DataStructures.Stack{Microlensing.CellNode}}"><code>Microlensing.calc_far_sums!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calc_far_sums!(far_sums, cell::Cell, P::NumMLProblem,
                    near_stars, stack)</code></pre><p>Records to the <code>far_sums</code> matrix the impacts of far stars for all the second level subcells of the first level <code>cell</code>. Also saves all the stars located near the <code>cell</code> to the <code>near_stars</code> array.</p><p><code>stack</code> is just a preallocated stack necessary for searching through the tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L26-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.interpolate_far_sums!-Tuple{Any,NumMLProblem,Any,Any}" href="#Microlensing.interpolate_far_sums!-Tuple{Any,NumMLProblem,Any,Any}"><code>Microlensing.interpolate_far_sums!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">interpolate_far_sums!(int_far_sums, P::NumMLProblem,
                           real_fs, imag_fs)</code></pre><p>Calculates the interpolated impacts of the far stars for all the third level subcells of a first level cell and records them to the <code>int_far_sums</code> matrix. </p><p>The <code>real_fs</code> and <code>imag_fs</code> matrices should contain correspondingly the real and imaginary parts of the far stars impact on the second level subcells. This impact is normally computed with the <a href="#Microlensing.calc_far_sums!-Tuple{Any,Cell,NumMLProblem,Array{Star,1},DataStructures.Stack{Microlensing.CellNode}}"><code>calc_far_sums!</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L79-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_near_sums!-Tuple{Any,Any,Any,NumMLProblem,Any}" href="#Microlensing.calc_near_sums!-Tuple{Any,Any,Any,NumMLProblem,Any}"><code>Microlensing.calc_near_sums!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calc_near_sums!(int_near_sums, near_stars, 
                     nnstars, P::NumMLProblem, int_grid_mat)</code></pre><p>Calculates the impact of all the stars close to a first level cell on its third level subcells. </p><p><code>nnstars</code> is the number of the near stars (it is less than <code>length(near_stars)</code>!) </p><p><code>int_grid_mat</code> is just a matrix of the upper left corners of the third level subcells.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L108-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.find_cell-Tuple{Any,Any,Any}" href="#Microlensing.find_cell-Tuple{Any,Any,Any}"><code>Microlensing.find_cell</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">find_cell(pos, imsize, nimgrid)</code></pre><p>By the position <code>pos</code> of a point in the image plane finds the indicies of an image grid cell containing this point.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L139-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.update_mag!-Tuple{Any,Any,Microlensing.Grid,NumMLProblem}" href="#Microlensing.update_mag!-Tuple{Any,Any,Microlensing.Grid,NumMLProblem}"><code>Microlensing.update_mag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update_mag!(mag, lense, image_grid::Grid,
                 P::NumMLProblem)</code></pre><p>Updates the magnification map <code>mag</code> taking into account the lense map <code>lense</code> computed for all the rays from a first level cell.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L154-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.normalize_mag-Tuple{Any,NumMLProblem,Cell,Cell}" href="#Microlensing.normalize_mag-Tuple{Any,NumMLProblem,Cell,Cell}"><code>Microlensing.normalize_mag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">normalize_mag(mag, P::NumMLProblem, domain::Cell, image::Cell)</code></pre><p>Normalizes the magnification map in such a way that magnification is equal to 1 on the infinity.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L180-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.calc_mag-Tuple{NumMLProblem,Cell,Cell}" href="#Microlensing.calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>Microlensing.calc_mag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calc_mag(P::NumMLProblem, domain::Cell, image::Cell)</code></pre><p>Just computes the magnification map. Output is normalized in such a way that the magnification is equal to 1 at the infinity.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/magnification.jl#L191-L195">source</a></section><h2><a class="nav-anchor" id="Parallel-magnification-1" href="#Parallel-magnification-1">Parallel magnification</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.range_calc_mag-Tuple{UnitRange{Int64},NumMLProblem,Cell,Cell}" href="#Microlensing.range_calc_mag-Tuple{UnitRange{Int64},NumMLProblem,Cell,Cell}"><code>Microlensing.range_calc_mag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">range_calc_mag(r::UnitRange{Int}, P::NumMLProblem, domain::Cell, image::Cell)</code></pre><p>Just computes the magnification map for the rows with numbers from the range <code>r</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-magnification.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.break_into_ranges-Tuple{Any,Any}" href="#Microlensing.break_into_ranges-Tuple{Any,Any}"><code>Microlensing.break_into_ranges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">break_into_ranges(n, nranges)</code></pre><p>Breaks the range <code>1:n</code> into a union of <code>nranges</code> ranges <code>1:x1</code>, <code>(x1+1):x2</code>, ..., <code>(xk+1):n</code>. Sizes of the resulting ranges cannot differ by more than 1. It is used by the <a href="#Microlensing.par_calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>par_calc_mag</code></a> function to split the task between the workers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-magnification.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.par_calc_mag-Tuple{NumMLProblem,Cell,Cell}" href="#Microlensing.par_calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>Microlensing.par_calc_mag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">par_calc_mag(P::NumMLProblem, domain::Cell, image::Cell)</code></pre><p>Does the same as <a href="#Microlensing.calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>calc_mag</code></a>, but in a parallel way. The progress bar does not work yet.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-magnification.jl#L81-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.range_calc_mag!-Tuple{Any,Any,UnitRange{Int64},NumMLProblem,Cell,Cell}" href="#Microlensing.range_calc_mag!-Tuple{Any,Any,UnitRange{Int64},NumMLProblem,Cell,Cell}"><code>Microlensing.range_calc_mag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">range_calc_mag(r::UnitRange{Int}, P::NumMLProblem, domain::Cell, image::Cell)</code></pre><p>Does the same as <a href="#Microlensing.range_calc_mag-Tuple{UnitRange{Int64},NumMLProblem,Cell,Cell}"><code>range_calc_mag</code></a>, but takes a <code>SharedArray</code> <code>mag</code> as an argument. See <a href="#Microlensing.shared_calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>shared_calc_mag</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-magnification.jl#L121-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.shared_calc_mag-Tuple{NumMLProblem,Cell,Cell}" href="#Microlensing.shared_calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>Microlensing.shared_calc_mag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shared_calc_mag(P::NumMLProblem, domain::Cell, image::Cell)</code></pre><p>Does the same as <a href="#Microlensing.par_calc_mag-Tuple{NumMLProblem,Cell,Cell}"><code>par_calc_mag</code></a>, but uses a <code>SharedArray</code> for the result. It is a little bit slower, but uses memory efficiently.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/parallel-magnification.jl#L97-L101">source</a></section><h2><a class="nav-anchor" id="Distributions-1" href="#Distributions-1">Distributions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Microlensing.Power" href="#Microlensing.Power"><code>Microlensing.Power</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Power(α, a, b)</code></pre><p>The <em>Power</em> distribution with shape <code>α</code> and support <code>[a, b]</code> has probability density function </p><div>\[    f(x, \, \alpha, \, a, \, b) = \begin{cases}
        \dfrac{1+\alpha}{b^{1+\alpha} - a^{1+\alpha}} \, x^{\alpha}, \quad \alpha \neq -1; \\
        \dfrac{1}{\log\left(\tfrac{b}{a}\right) \, x}, \quad \alpha = 1.
    \end{cases}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/mikle97pir/Microlensing.jl/blob/d0c2baa3191457f6bfde96269be8e2bb3911707e/src/star-field/distributions/power.jl#L1-L12">source</a></section><footer><hr/></footer></article></body></html>
