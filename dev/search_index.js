var documenterSearchIndex = {"docs":
[{"location":"#Sources-1","page":"Sources","title":"Sources","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"CurrentModule = Microlensing","category":"page"},{"location":"#Utils-1","page":"Sources","title":"Utils","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    calc_binomials(order)\n    simple_newton(f, ∂f, init)\n    check_for_duplicates(array)\n    break_into_ranges(n::Int, nranges::Int)","category":"page"},{"location":"#Microlensing.calc_binomials-Tuple{Any}","page":"Sources","title":"Microlensing.calc_binomials","text":"calc_binomials(order)\n\nComputes binomials. Returns matrix of signature (order, order), binomials[i, j] should be equal to binomial(j-1, i-1). It is used in the calc_multipoles! function .\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.simple_newton-Tuple{Any,Any,Any}","page":"Sources","title":"Microlensing.simple_newton","text":"simple_newton(f, ∂f, init)\n\nFinds the root of the complex function f near the initial value init. ∂f is the derivative of f. The function is a straightforward implementation of Newton method. It it used by default, for example, in calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.check_for_duplicates-Tuple{Any}","page":"Sources","title":"Microlensing.check_for_duplicates","text":"check_for_duplicates(array)\n\nReturns true if the array contains approximate(≈) duplicates. Else returnes false. It is used in the duplicate_warning_roots function.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.break_into_ranges-Tuple{Int64,Int64}","page":"Sources","title":"Microlensing.break_into_ranges","text":"break_into_ranges(n::Int, nranges::Int)\n\nBreaks the range 1:n into a union of nranges ranges 1:x1, (x1+1):x2, ..., (xk+1):n. Sizes of the resulting ranges cannot differ by more than 1. It is used by the par_calc_mag function to split the task between the workers.\n\n\n\n\n\n","category":"method"},{"location":"#Caustics-1","page":"Sources","title":"Caustics","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    find_corrections(masses, positions, δs, E, Λ)\n    find_start_roots(mass_homotopy, positions, init1, init2, δs, find_root)\n    homotopy_step(t0, s0, homotopy, Δs, find_root)\n    auto_homotopy_step(t0, s0, homotopy, rate, lim_func, find_root)\n    homotopize(t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)\n    homotopize_and_remember!(t_list, s_list, t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)\n    homotopize_and_remember(t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)\n    create_mass_homotopy(masses, positions, E, Λ)\n    create_angle_homotopy(masses, positions, E, Λ)\n    mass_lim_func(t0, s0, rate)\n    evaluate_mass_homotopy(masses, positions, E, Λ, δs, rate, find_root)\n    evaluate_angle_homotopy(roots, masses, positions, E, Λ, rate, nsteps, find_root)\n    duplicate_warning_crit_curves(crit_curves)\n    duplicate_warning_roots(roots)\n    calc_crit_curves(stars::Vector{Star}; E, Λ, δs=1e-6, rate=0.1, nsteps=500, find_root=simple_newton)\n    calc_caustics(stars::Vector{Star}, crit_curves; E, Λ)","category":"page"},{"location":"#Microlensing.find_corrections-NTuple{5,Any}","page":"Sources","title":"Microlensing.find_corrections","text":"find_corrections(masses, positions, δs, E, Λ)\n\nFinds the approximate positions of the 2*nstars roots of the jacobian, when all the masses are multiplied by a small number δs. The output arrays init1 and init2 should be used for the function find_start_roots.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.find_start_roots-NTuple{6,Any}","page":"Sources","title":"Microlensing.find_start_roots","text":"find_start_roots(mass_homotopy, positions, init1, init2, δs, find_root)\n\nFinds the exact positions of the 2*nstars roots of the jacobian, when all the masses are multiplied by a small number δs. The init1 and init2 initial approximations should be computed by the function find_corrections. \n\nmass_homotopy is a tuple of functions (H, ∂tH, ∂sH, ∂ttH, ∂tsH) containing the mass-changing homotopy H(t, s) and its derivatives. It should be generated by the function create_mass_homotopy.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.homotopy_step-NTuple{5,Any}","page":"Sources","title":"Microlensing.homotopy_step","text":"homotopy_step(t0, s0, homotopy, Δs, find_root)\n\nFinds t such that F(t, s) = 0, where s = s0 + Δs and F(t0, s0) = 0. Returns t and s.\n\nhomotopy is a tuple of functions (F, ∂tF, ∂sF, ∂ttF, ∂tsF) containing an arbitrary homotopy F(t, s) and its derivatives.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.auto_homotopy_step-NTuple{6,Any}","page":"Sources","title":"Microlensing.auto_homotopy_step","text":"auto_homotopy_step(t0, s0, homotopy, rate, lim_func, find_root)\n\nDoes the same as homotopy_step, but the step Δs is determined automatically. \n\nlim_func is a function with arguments t0, s0, rate that limits the step from the above. For the mass-changing homotopy we use mass_lim_func. For the angle-changing homotopy it is just a constant 2π / nsteps.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.homotopize-NTuple{7,Any}","page":"Sources","title":"Microlensing.homotopize","text":"homotopize(t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)\n\nFinds t such that F(t, s_finish) = 0, if it's known that F(t_start, s_start) = 0. Returns t. Does this by repeating auto_homotopy_step many times to get from s_start to s_finish. \n\nSee also: calc_crit_curves, homotopy_step.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.homotopize_and_remember!-NTuple{9,Any}","page":"Sources","title":"Microlensing.homotopize_and_remember!","text":"homotopize_and_remember!(t_list, s_list, t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)\n\nDoes the same as homotopize, but saves all the intermediate values of t and s to empty lists t_list and s_list respectively. \n\nSee also: calc_crit_curves, homotopy_step.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.homotopize_and_remember-NTuple{7,Any}","page":"Sources","title":"Microlensing.homotopize_and_remember","text":"homotopize_and_remember(t_start, s_start, s_finish, homotopy, rate, lim_func, find_root)\n\nDoes the same as homotopize_and_remember!, but creates t_list and slistitself and returnstlist`.\n\nSee also: calc_crit_curves, homotopy_step.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.create_mass_homotopy-NTuple{4,Any}","page":"Sources","title":"Microlensing.create_mass_homotopy","text":"create_mass_homotopy(masses, positions, E, Λ)\n\nReturns the tuple mass_homotopy containing the mass-changing homotopy H and its derivatives ∂tH, ∂sH, ∂ttH, ∂tsH.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.create_angle_homotopy-NTuple{4,Any}","page":"Sources","title":"Microlensing.create_angle_homotopy","text":"create_angle_homotopy(masses, positions, E, Λ)\n\nReturns the tuple angle_homotopy containing the angle-changing homotopy G and its derivatives ∂tG, ∂sG, ∂ttG, ∂tsG.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.mass_lim_func-Tuple{Any,Any,Any}","page":"Sources","title":"Microlensing.mass_lim_func","text":"mass_lim_func(t0, s0, rate)\n\nA limiting function for the step in the mass-changing homotopy.\n\nSee also: evaluate_mass_homotopy, homotopize_and_remember!, homotopize, auto_homotopy_step, calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.evaluate_mass_homotopy-NTuple{7,Any}","page":"Sources","title":"Microlensing.evaluate_mass_homotopy","text":"evaluate_mass_homotopy(masses, positions, E, Λ, δs, rate, find_root)\n\nEvaluates the mass-changing homotopy from δs to 1 and returns the array with the roots of the jacobian for the angle equal to zero.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.evaluate_angle_homotopy-NTuple{8,Any}","page":"Sources","title":"Microlensing.evaluate_angle_homotopy","text":"evaluate_angle_homotopy(roots, masses, positions, E, Λ, rate, nsteps, find_root)\n\nEvaluates the angle-changing homotopy from 0 to 2π and returns a Vector{Vector{Complex{Float64}}}, which consists of vectors of points lying on the critical curves.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.duplicate_warning_crit_curves-Tuple{Any}","page":"Sources","title":"Microlensing.duplicate_warning_crit_curves","text":"duplicate_warning_crit_curves(crit_curves)\n\nPrints a warning if there are roots which glued to each other during the angle-changing homotopy.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.duplicate_warning_roots-Tuple{Any}","page":"Sources","title":"Microlensing.duplicate_warning_roots","text":"duplicate_warning_roots(roots)\n\nPrints a warning if there are roots which glued to each other during the mass-changing homotopy.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.calc_crit_curves-Tuple{Array{Star,1}}","page":"Sources","title":"Microlensing.calc_crit_curves","text":"calc_crit_curves(stars::Vector{Star}; E, Λ, δs=1e-6, rate=0.25, nsteps=200, find_root=simple_newton)\n\nNormally returns a Vector{Vector{Complex{Float64}}}, which consists of vectors of points lying on the critical curves.\n\nArguments\n\nstars: the array of stars.\nE, Λ: the lens parameters describing the external shear.\nδs: the starting parameter of the mass-changing homotopy; should be a small real number.\nrate: increasing this parameter effectively increases the adaptive step.\nnsteps: the minimal number of steps in the angle-changing homotopy; you should increase it if you want smoother curves.\nfind_root: the root finder; its argumetns should be a complex function f, its derivative ∂f and the initial approximation init.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.calc_caustics-Tuple{Array{Star,1},Any}","page":"Sources","title":"Microlensing.calc_caustics","text":"calc_caustics(stars::Vector{Star}, crit_curves; E, Λ)\n\nComputes the caustics by given critical curves crit_curves. \n\nSee also: calc_crit_curves. \n\n\n\n\n\n","category":"method"},{"location":"#Parallel-caustics-1","page":"Sources","title":"Parallel caustics","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    par_evaluate_mass_homotopy(masses, positions, E, Λ, δs, rate, find_root)\n    par_evaluate_angle_homotopy(roots, masses, positions, E, Λ, rate, nsteps, find_root=simple_newton)\n    par_calc_crit_curves(stars::Vector{Star}; E, Λ, δs=1e-6, rate=0.1, nsteps=500, find_root=simple_newton)","category":"page"},{"location":"#Microlensing.par_evaluate_mass_homotopy-NTuple{7,Any}","page":"Sources","title":"Microlensing.par_evaluate_mass_homotopy","text":"par_evaluate_mass_homotopy(masses, positions, E, Λ, δs, rate, find_root)\n\nDoes the same as evaluate_mass_homotopy, but in a parallel way.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.par_evaluate_angle_homotopy","page":"Sources","title":"Microlensing.par_evaluate_angle_homotopy","text":"evaluate_angle_homotopy(roots, masses, positions, E, Λ, rate, nsteps, find_root)\n\nDoes the same as evaluate_angle_homotopy, but in a parallel way.\n\nSee also: calc_crit_curves.\n\n\n\n\n\n","category":"function"},{"location":"#Microlensing.par_calc_crit_curves-Tuple{Array{Star,1}}","page":"Sources","title":"Microlensing.par_calc_crit_curves","text":"par_calc_crit_curves(stars::Vector{Star}; E, Λ, δs=1e-6, rate=0.25, nsteps=200, find_root=simple_newton)\n\nDoes the same as calc_crit_curves, but in a parallel way.\n\n\n\n\n\n","category":"method"},{"location":"#Grids-and-cells-1","page":"Sources","title":"Grids and cells","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    get_index_leftup(grid::AbstractGrid, i, j)\n    get_index_center(grid::AbstractGrid, i, j)\n    Base.getindex(grid::AbstractGrid, i::Int, j::Int)\n    matrix_rep(grid::RectGrid, n=grid.ngrid; kind=:center)\n    matrix_rep!(matrix, grid::RectGrid, n=grid.ngrid; kind=:center)\n    matrix_rep(grid::SquareGrid, n=grid.ngrid; kind=:center)\n    matrix_rep!(matrix, grid::SquareGrid, n=grid.ngrid; kind=:center)","category":"page"},{"location":"#Microlensing.get_index_leftup-Tuple{Microlensing.AbstractGrid,Any,Any}","page":"Sources","title":"Microlensing.get_index_leftup","text":"get_index_leftup(grid::SquareGrid, i, j)\n\nReturns the complex coordinate of the upper left corner of the cell from the i-th row and j-th column.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.get_index_center-Tuple{Microlensing.AbstractGrid,Any,Any}","page":"Sources","title":"Microlensing.get_index_center","text":"get_index_center(grid::AbstractGrid, i, j)\n\nReturns the complex coordinate of the center of the cell from the i-th row and j-th column.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{Microlensing.AbstractGrid,Int64,Int64}","page":"Sources","title":"Base.getindex","text":"Base.getindex(grid::AbstractGrid, i::Int, j::Int)\n\nReturns the cell from the i-th row and j-th column.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.matrix_rep","page":"Sources","title":"Microlensing.matrix_rep","text":"matrix_rep(grid::RectGrid, n=grid.ngrid, kind=[:center or :leftup])\n\nSee also: matrix_rep!\n\n\n\n\n\n","category":"function"},{"location":"#Microlensing.matrix_rep!","page":"Sources","title":"Microlensing.matrix_rep!","text":"matrix_rep!(matrix, grid::RectGrid, n=grid.ngrid; kind=[:center or :leftup])\n\nFills the matrix with the complex coordinates of the cells from grid. They can be either centers or upper left corners depending on kind argument.\n\nn argument tells where to stop: signature of resulting matrix is equal to n. \n\n\n\n\n\n","category":"function"},{"location":"#Microlensing.matrix_rep","page":"Sources","title":"Microlensing.matrix_rep","text":"matrix_rep(grid::SquareGrid, n=grid.ngrid, kind=[:center or :leftup])\n\nSee also: matrix_rep!\n\n\n\n\n\n","category":"function"},{"location":"#Microlensing.matrix_rep!","page":"Sources","title":"Microlensing.matrix_rep!","text":"matrix_rep!(matrix, grid::SquareGrid, n=grid.ngrid; kind=[:center or :leftup])\n\nFills the matrix with the complex coordinates of the cells from grid. They can be either centers or upper left corners depending on kind argument.\n\nn argument tells where to stop: signature of resulting matrix is (n, n). \n\n\n\n\n\n","category":"function"},{"location":"#Cell-trees-1","page":"Sources","title":"Cell trees","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    CellNode()\n    CellNode(sink::CellNode, size::Float64, order::Int)\n    CellTree(size::Float64, order::Int)\n    next_index(cell::CellNode, star::Star)\n    child_center(cell::CellNode, i::Int)\n    update_cell!(cell::CellNode, star::Star)\n    add_cell!(T::CellTree, cell::CellNode, star::Star, i::Int)\n    add_star!(T::CellTree, star::Star)\n    update_cell_multipoles!(cell::CellNode, child::CellNode, degrees::Vector{Complex{Float64}}, order::Int, binomials::Matrix{Int})\n    calc_multipoles!(T::CellTree)\n    build_tree(stars::Vector{Star}; width::Float64, order::Int=6)","category":"page"},{"location":"#Microlensing.CellNode-Tuple{}","page":"Sources","title":"Microlensing.CellNode","text":"CellNode()\n\nCreates a self-referential sink. It is a placeholder for non-existing children.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.CellNode-Tuple{Microlensing.CellNode,Float64,Int64}","page":"Sources","title":"Microlensing.CellNode","text":"CellNode(sink::CellNode, size::Float64, order::Int)\n\nCreates a node without children. Array children consists of four sinks. order is the higher multipole degree taken into account.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.CellTree-Tuple{Float64,Int64}","page":"Sources","title":"Microlensing.CellTree","text":"CellTree(size::Float64, order::Int)\n\nCreates a tree composed only of a root. All root's children are set to sink.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.next_index-Tuple{Microlensing.CellNode,Star}","page":"Sources","title":"Microlensing.next_index","text":"next_index(cell::CellNode, star::Star)\n\nReturns the index of cell's child containing given star.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.child_center-Tuple{Microlensing.CellNode,Int64}","page":"Sources","title":"Microlensing.child_center","text":"child_center(cell::CellNode, i::Int)\n\nReturns the center of the i-th child of the cell.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.update_cell!-Tuple{Microlensing.CellNode,Star}","page":"Sources","title":"Microlensing.update_cell!","text":"update_cell!(cell::CellNode, star::Star)\n\nUpdates mass and pos of the cell when the star is added.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.add_cell!-Tuple{Microlensing.CellTree,Microlensing.CellNode,Star,Int64}","page":"Sources","title":"Microlensing.add_cell!","text":"add_cell!(T::CellTree, cell::CellNode, star::Star, i::Int)\n\nAdds an i-th child containing star to the cell.\n\nThe square corresponding to the child must contain star.pos!\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.add_star!-Tuple{Microlensing.CellTree,Star}","page":"Sources","title":"Microlensing.add_star!","text":"add_star!(T::CellTree, star::Star)\n\nAdds star to tree T.\n\nIt goes down the tree and modifies the cells until it meets a leaf. It then lengthens the branch until the stars are in different children.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.update_cell_multipoles!-Tuple{Microlensing.CellNode,Microlensing.CellNode,Array{Complex{Float64},1},Int64,Array{Int64,2}}","page":"Sources","title":"Microlensing.update_cell_multipoles!","text":"update_cell_multipoles!(cell::CellNode, child::CellNode, \n                        degrees::Vector{Complex{Float64}}, \n                        order::Int, binomials::Matrix{Int})\n\nUpdates cell.multipoles taking into account already known child.multipoles.\n\nArguments\n\ncell::CellNode: the cell being updated.\nchild::CellNode: the child being taken into account.\ndegrees::Vector{Complex{Float64}}: vector of length order+1. It's a temporary array for keeping degrees of A-B from 0 to order.\norder::Int: the degree of the highest multipole taken into account.\nbinomials::Matrix{Int}: matrix of signature (order, order). binomials[i, j] should be equal to binomial(j-1, i-1). It is normally computed by the calc_binomials function. \n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.calc_multipoles!-Tuple{Microlensing.CellTree}","page":"Sources","title":"Microlensing.calc_multipoles!","text":"calc_multipoles!(T::CellTree)\n\nCalculates multipoles for the whole tree. All the stars should be already added. The function propagates multipoles from the leaves to the root.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.build_tree-Tuple{Array{Star,1}}","page":"Sources","title":"Microlensing.build_tree","text":"build_tree(stars::Vector{Star}; width::Float64, order::Int=6)\n\nCreates CellTree from a given array of stars. The root is centered at zero. \n\norder represents the highest multipole degree taken into account.\n\n\n\n\n\n","category":"method"},{"location":"#Magnification-1","page":"Sources","title":"Magnification","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    NumMLProblem\n    calc_far_sums!(far_sums, cell::Cell, P::NumMLProblem, near_stars::Vector{Star}, stack::Stack{CellNode})\n    interpolate_far_sums!(int_far_sums, P::NumMLProblem, real_fs, imag_fs)\n    calc_near_sums!(int_near_sums, near_stars, nnstars, P::NumMLProblem, int_grid_mat)\n    find_cell(pos, image::RectGrid)\n    update_mag!(mag, lense, image::RectGrid, P::NumMLProblem)\n    update_mag!(mag::DArray, lense, image::RectGrid, P::NumMLProblem)\n    calc_mag(P::NumMLProblem, domain::RectGrid, image::RectGrid)","category":"page"},{"location":"#Microlensing.NumMLProblem","page":"Sources","title":"Microlensing.NumMLProblem","text":"Fields\n\nT::CellTree: normally is created with the build_tree function.\nnstars::Int: number of stars in simulation.\nnshare::Int: nshare^2 is the number of the second level subcells of a first level cell. For them the computation is complete, but they all share the same tree structure of the first level cell containing them.\nnint::Int: nint^2 is the number of the third level subcells of a second level cell. For them the algorithm attentively takes care of the stars located near the corresponding first level cell, but the impact of all other stars is interpolated.\nE::Float64: first parameter of the shear.\nΛ::Float64: second parameter of the shear.\nδ::Float64: the precision parameter. Higher δ - higher precision!\n\n\n\n\n\n","category":"type"},{"location":"#Microlensing.calc_far_sums!-Tuple{Any,Microlensing.Cell,NumMLProblem,Array{Star,1},DataStructures.Stack{Microlensing.CellNode}}","page":"Sources","title":"Microlensing.calc_far_sums!","text":"calc_far_sums!(far_sums, cell::Cell, P::NumMLProblem,\n                    near_stars, stack)\n\nRecords to the far_sums matrix the impacts of far stars for all the second level subcells of the first level cell. Also saves all the stars located near the cell to the near_stars array.\n\nstack is just a preallocated stack necessary for searching through the tree.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.interpolate_far_sums!-Tuple{Any,NumMLProblem,Any,Any}","page":"Sources","title":"Microlensing.interpolate_far_sums!","text":"interpolate_far_sums!(int_far_sums, P::NumMLProblem,\n                           real_fs, imag_fs)\n\nCalculates the interpolated impacts of the far stars for all the third level subcells of a first level cell and records them to the int_far_sums matrix. \n\nThe real_fs and imag_fs matrices should contain correspondingly the real and imaginary parts of the far stars impact on the second level subcells. This impact is normally computed with the calc_far_sums! function.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.calc_near_sums!-Tuple{Any,Any,Any,NumMLProblem,Any}","page":"Sources","title":"Microlensing.calc_near_sums!","text":"calc_near_sums!(int_near_sums, near_stars, \n                     nnstars, P::NumMLProblem, int_grid_mat)\n\nCalculates the impact of all the stars close to a first level cell on its third level subcells. \n\nnnstars is the number of the near stars (it is less than length(near_stars)!) \n\nint_grid_mat is just a matrix of the upper left corners of the third level subcells.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.find_cell-Tuple{Any,RectGrid}","page":"Sources","title":"Microlensing.find_cell","text":"find_cell(pos, image::RectGrid)\n\nBy the position pos of a point in the image plane finds the indicies of an image grid cell containing this point.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.update_mag!-Tuple{Any,Any,RectGrid,NumMLProblem}","page":"Sources","title":"Microlensing.update_mag!","text":"update_mag!(mag, lense, image::RectGrid,\n                 P::NumMLProblem)\n\nUpdates the magnification map mag taking into account the lense map lense computed for all the rays from a first level cell.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.update_mag!-Tuple{DistributedArrays.DArray,Any,RectGrid,NumMLProblem}","page":"Sources","title":"Microlensing.update_mag!","text":"update_mag!(mag::DArray, lense, image::RectGrid,\n                 P::NumMLProblem)\n\nA method of update_mag! for a distributed mag. Updates only the mag.localpart on every worker.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.calc_mag-Tuple{NumMLProblem,RectGrid,RectGrid}","page":"Sources","title":"Microlensing.calc_mag","text":"calc_mag(P::NumMLProblem, domain::RectGrid, image::RectGrid)\n\nJust computes the magnification map. Output is normalized in such a way that the magnification is equal to 1 at the infinity.\n\n\n\n\n\n","category":"method"},{"location":"#Parallel-magnification-1","page":"Sources","title":"Parallel magnification","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    range_calc_mag!(mag, r::UnitRange{Int}, P::NumMLProblem, domain::RectGrid, image::RectGrid, channel::RemoteChannel{Channel{Bool}})\n    shared_calc_mag(P::NumMLProblem, domain::RectGrid, image::RectGrid)\n    par_calc_mag(P::NumMLProblem, domain::RectGrid, image::RectGrid, tmp_path=\"./\")\n    temp_save_mags(mag::DArray, tmp_path=\"./\")\n    sum_mags(image::RectGrid, tmp_path=\"./\")","category":"page"},{"location":"#Microlensing.range_calc_mag!-Tuple{Any,UnitRange{Int64},NumMLProblem,RectGrid,RectGrid,Distributed.RemoteChannel{Channel{Bool}}}","page":"Sources","title":"Microlensing.range_calc_mag!","text":"range_calc_mag!(mag, r::UnitRange{Int}, P::NumMLProblem, domain::Cell, image::Cell, channel::RemoteChannel{Channel{Bool}})\n\nComputes the magnification map for a part of the set of rays (with row numbers from the range r) and adds it to mag. It is used by par_calc_mag to do a part of the job on one of the workers. The channel is used to transmit information about the calculation progress. \n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.shared_calc_mag-Tuple{NumMLProblem,RectGrid,RectGrid}","page":"Sources","title":"Microlensing.shared_calc_mag","text":"shared_calc_mag(P::NumMLProblem, domain::Cell, image::Cell)\n\nDoes the same as calc_mag, but in a parallel way. It is fast and memory efficient, but thread unsafe. You should use calc_mag or par_calc_mag if you need a completely correct answer.\n\n\n\n\n\n","category":"method"},{"location":"#Microlensing.par_calc_mag","page":"Sources","title":"Microlensing.par_calc_mag","text":"par_calc_mag(P::NumMLProblem, domain::Cell, image::Cell, tmp_path=\"./\")\n\nDoes the same as calc_mag, but in a parallel way. Uses hard drive for large temporary arrays, therefore may be too slow for short computations.\n\n\n\n\n\n","category":"function"},{"location":"#Microlensing.temp_save_mags","page":"Sources","title":"Microlensing.temp_save_mags","text":"temp_save_mags(mag::DArray, tmp_path=\"./\")\n\nSaves mag.localpart to a temporary .jld file on every worker. mag.size should be equal to (N, N, nworkers()) with a (N, N, 1)-part on every worker.\n\n\n\n\n\n","category":"function"},{"location":"#Microlensing.sum_mags","page":"Sources","title":"Microlensing.sum_mags","text":"sum_mags(resol::Int, tmp_path=\"./\")\n\nLoads all the files created by temp_save_mags and calculates sum(mag, dims=3).\n\n\n\n\n\n","category":"function"},{"location":"#Distributions-1","page":"Sources","title":"Distributions","text":"","category":"section"},{"location":"#","page":"Sources","title":"Sources","text":"    Power","category":"page"},{"location":"#Microlensing.Power","page":"Sources","title":"Microlensing.Power","text":"Power(α, a, b)\n\nThe Power distribution with shape α and support [a, b] has probability density function \n\n    f(x  alpha  a  b) = begincases\n        dfrac1+alphab^1+alpha - a^1+alpha  x^alpha quad alpha neq -1 \n        dfrac1logleft(tfracbaright)  x quad alpha = 1\n    endcases\n\n\n\n\n\n","category":"type"}]
}
